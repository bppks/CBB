local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

-- Settings
local aimbotEnabled = true
local espEnabled = true
local espTracersEnabled = true
local espBoxesEnabled = true
local espNamesEnabled = true
local espDistancesEnabled = true
local espHealthEnabled = true

local aimbotFOV = 120 -- degrees
local aimbotSmoothing = 0.3 -- smaller is faster snap
local aimbotKey = Enum.KeyCode.E -- hold to aim

-- FOV Circle Setup
local FOVCircle = Drawing.new("Circle")
FOVCircle.Transparency = 1
FOVCircle.Thickness = 2
FOVCircle.Color = Color3.new(1, 0, 0)
FOVCircle.Radius = 150
FOVCircle.Filled = false
FOVCircle.Visible = true
-- Position it centered on screen initially:
FOVCircle.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)

-- Update FOVCircle position on viewport resize
Camera:GetPropertyChangedSignal("ViewportSize"):Connect(function()
    FOVCircle.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
end)

-- To toggle aimbot with key hold
local aimbotActive = false
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if not gameProcessed and input.KeyCode == aimbotKey then
        aimbotActive = true
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.KeyCode == aimbotKey then
        aimbotActive = false
    end
end)

-- Helper function: Check if character is alive & visible
local function IsValidTarget(player)
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
        return false
    end
    local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
    if not humanoid or humanoid.Health <= 0 then
        return false
    end
    return true
end

-- Helper: World to screen position and visibility check
local function GetScreenPosition(part)
    local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
    return Vector2.new(screenPos.X, screenPos.Y), onScreen and screenPos.Z > 0
end

-- Cache ESP drawings per player
local espDrawings = {}

-- Main loop timers
local aimThrottle = 0
local espThrottle = 0
local aimInterval = 1/15 -- 15 times per second for aimbot
local espInterval = 1/10 -- 10 times per second for ESP

RunService.RenderStepped:Connect(function(dt)
    aimThrottle = aimThrottle + dt
    espThrottle = espThrottle + dt

    local mouse = LocalPlayer:GetMouse()
    local mousePos = Vector2.new(mouse.X, mouse.Y)

    -- Aimbot logic throttled
    if aimbotEnabled and aimbotActive and aimThrottle >= aimInterval then
        aimThrottle = 0

        local closestPlayer = nil
        local closestDistance = aimbotFOV

        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and IsValidTarget(player) then
                local rootPart = player.Character.HumanoidRootPart
                local screenPos, visible = Camera:WorldToViewportPoint(rootPart.Position)
                if visible and screenPos.Z > 0 then
                    local screenPos2D = Vector2.new(screenPos.X, screenPos.Y)
                    local distanceFromMouse = (screenPos2D - mousePos).Magnitude

                    -- Convert aimbotFOV degrees to pixels approx (circle radius)
                    -- We'll use FOVCircle radius for reference
                    if distanceFromMouse < closestDistance and distanceFromMouse <= FOVCircle.Radius then
                        closestDistance = distanceFromMouse
                        closestPlayer = player
                    end
                end
            end
        end

        if closestPlayer then
            local targetPos = closestPlayer.Character.HumanoidRootPart.Position
            local cameraPos = Camera.CFrame.Position
            local direction = (targetPos - cameraPos).Unit

            -- Calculate desired camera look vector
            local desiredCFrame = CFrame.new(cameraPos, targetPos)
            -- Smooth the camera movement for natural aiming
            Camera.CFrame = Camera.CFrame:Lerp(desiredCFrame, aimbotSmoothing)
        end
    end

    -- ESP logic throttled
    if espEnabled and espThrottle >= espInterval then
        espThrottle = 0

        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and IsValidTarget(player) then
                local rootPart = player.Character.HumanoidRootPart
                local screenPos, visible = Camera:WorldToViewportPoint(rootPart.Position)

                -- Create ESP drawings if not exist
                if not espDrawings[player] then
                    espDrawings[player] = {
                        box = Drawing.new("Square"),
                        tracer = Drawing.new("Line"),
                        nameText = Drawing.new("Text"),
                        distText = Drawing.new("Text"),
                        healthText = Drawing.new("Text"),
                    }

                    -- Box settings
                    espDrawings[player].box.Color = Color3.new(0, 1, 0)
                    espDrawings[player].box.Thickness = 2
                    espDrawings[player].box.Filled = false
                    espDrawings[player].box.Visible = false

                    -- Tracer line settings
                    espDrawings[player].tracer.Color = Color3.new(1, 0, 0)
                    espDrawings[player].tracer.Thickness = 1
                    espDrawings[player].tracer.Visible = false

                    -- Name text settings
                    espDrawings[player].nameText.Color = Color3.new(1, 1, 1)
                    espDrawings[player].nameText.Center = true
                    espDrawings[player].nameText.Outline = true
                    espDrawings[player].nameText.Visible = false

                    -- Distance text settings
                    espDrawings[player].distText.Color = Color3.new(1, 1, 1)
                    espDrawings[player].distText.Center = true
                    espDrawings[player].distText.Outline = true
                    espDrawings[player].distText.Visible = false

                    -- Health text settings
                    espDrawings[player].healthText.Color = Color3.new(1, 0, 0)
                    espDrawings[player].healthText.Center = true
                    espDrawings[player].healthText.Outline = true
                    espDrawings[player].healthText.Visible = false
                end

                local data = espDrawings[player]

                if visible and screenPos.Z > 0 then
                    local screenPos2D = Vector2.new(screenPos.X, screenPos.Y)
                    local humanoid = player.Character:FindFirstChildOfClass("Humanoid")

                    -- Box
                    if espBoxesEnabled then
                        local size = 50 -- You can make this dynamic based on distance
                        data.box.Size = Vector2.new(size, size)
                        data.box.Position = screenPos2D - Vector2.new(size/2, size/2)
                        data.box.Visible = true
                    else
                        data.box.Visible = false
                    end

                    -- Tracer
                    if espTracersEnabled then
                        data.tracer.From = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y)
                        data.tracer.To = screenPos2D
                        data.tracer.Visible = true
                    else
                        data.tracer.Visible = false
                    end

                    -- Name Text
                    if espNamesEnabled then
                        data.nameText.Text = player.Name
                        data.nameText.Position = screenPos2D + Vector2.new(0, -30)
                        data.nameText.Visible = true
                    else
                        data.nameText.Visible = false
                    end

                    -- Distance Text
                    if espDistancesEnabled then
                        local distance = math.floor((player.Character.HumanoidRootPart.Position - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude)
                        data.distText.Text = distance .. "m"
                        data.distText.Position = screenPos2D + Vector2.new(0, 20)
                        data.distText.Visible = true
                    else
                        data.distText.Visible = false
                    end

                    -- Health Text
                    if espHealthEnabled and humanoid then
                        data.healthText.Text = "HP: " .. math.floor(humanoid.Health)
                        data.healthText.Position = screenPos2D + Vector2.new(0, 10)
                        data.healthText.Visible = true
                    else
                        data.healthText.Visible = false
                    end

                else
                    -- Hide if off-screen
                    data.box.Visible = false
                    data.tracer.Visible = false
                    data.nameText.Visible = false
                    data.distText.Visible = false
                    data.healthText.Visible = false
                end
            else
                -- Hide for invalid targets or local player
                if espDrawings[player] then
                    espDrawings[player].box.Visible = false
                    espDrawings[player].tracer.Visible = false
                    espDrawings[player].nameText.Visible = false
                    espDrawings[player].distText.Visible = false
                    espDrawings[player].healthText.Visible = false
                end
            end
        end
    end
end)
