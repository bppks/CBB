--// Services
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Camera = workspace.CurrentCamera

--// Rayfield UI Loader
local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()
if not Rayfield then
    warn("Rayfield did not load! UI will not work.")
    return
end

--// Create Main Window
local Window = Rayfield:CreateWindow({
    Name = "                                      ðŸ˜œCBBðŸ˜œ",
    Icon = "croissant",
    LoadingTitle = "CBB Hub",
    LoadingSubtitle = "by bppks",
    Theme = "Amethyst",
    ToggleUIKeybind = Enum.KeyCode.RightAlt,
    DisableRayfieldPrompts = false,
    DisableBuildWarnings = false,
    ConfigurationSaving = {Enabled = false, FolderName = nil, FileName = "CBB Hub"},
    Discord = {Enabled = false, Invite = "noinvitelink", RememberJoins = true},
    KeySystem = false,
    KeySettings = {
        Title = "CBB | Key",
        Subtitle = "Key System",
        Note = "Be a good boy and you will get the key",
        FileName = "CBBkey",
        SaveKey = false,
        GrabKeyFromSite = true,
        Key = {"https://pastebin.com/raw/z9HnSX6f"}
    }
})

-----------------------------------------------------------------
-- Aimbot Section
-----------------------------------------------------------------
local MainTab = Window:CreateTab("Aimbot", "Crosshair")
MainTab:CreateSection("Main")
local aimbotEnabled, aimbotWallCheck, aimbotTeamCheck = false, false, false

MainTab:CreateToggle({ Name = "Aimbot", CurrentValue = false, Callback = function(Value)
    aimbotEnabled = Value
    Rayfield:Notify({Title = "Aimbot", Content = "Aimbot is now " .. (aimbotEnabled and "ON" or "OFF"), Duration = 2})
end })
MainTab:CreateToggle({ Name = "Aimbot Wall Check", CurrentValue = false, Callback = function(Value)
    aimbotWallCheck = Value
    Rayfield:Notify({Title = "Aimbot", Content = "Wall Check is now " .. (aimbotWallCheck and "ON" or "OFF"), Duration = 2})
end })
MainTab:CreateToggle({ Name = "Aimbot Team Check (Ignore teammates)", CurrentValue = false, Callback = function(Value)
    aimbotTeamCheck = Value
    Rayfield:Notify({Title = "Aimbot", Content = "Aimbot Team Check is now " .. (aimbotTeamCheck and "ON" or "OFF"), Duration = 2})
end })

-- FOV Circle
local FOVCircle = Drawing.new("Circle")
FOVCircle.Visible = false
FOVCircle.Color = Color3.fromRGB(255, 0, 0)
FOVCircle.Thickness = 2
FOVCircle.Filled = false
FOVCircle.Radius = 100
FOVCircle.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)

MainTab:CreateToggle({ Name = "Show FOV", CurrentValue = false, Callback = function(Value)
    FOVCircle.Visible = Value
    Rayfield:Notify({Title = "FOV", Content = "FOV Circle is now " .. (FOVCircle.Visible and "ON" or "OFF"), Duration = 2})
end })
MainTab:CreateSlider({ Name = "Aimbot FOV Radius", Range = {0, 1000}, Increment = 5, Suffix = "Pixels", CurrentValue = 100, Flag = "AimbotFOV", Callback = function(Value)
    FOVCircle.Radius = Value
end })
RunService.RenderStepped:Connect(function()
    FOVCircle.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
end)

-- Aimbot Logic
local function IsTargetInFOV(targetPosition)
    local screenPosition, onScreen = Camera:WorldToViewportPoint(targetPosition)
    if onScreen then
        local distance = (Vector2.new(screenPosition.X, screenPosition.Y) - FOVCircle.Position).Magnitude
        return distance <= FOVCircle.Radius
    end
    return false
end

local function GetAllTargets()
    local targets = {}
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("Head") then
            if not aimbotTeamCheck or player.Team ~= LocalPlayer.Team then
                table.insert(targets, player)
            end
        end
    end
    return targets
end
local function GetTargetPosition(target)
    if target and target.Character and target.Character:FindFirstChild("Head") then
        return target.Character.Head.Position
    end
    return nil
end

local function IsVisible(target)
    -- Simple raycast for wall check
    local char = LocalPlayer.Character
    local head = char and char:FindFirstChild("Head")
    local targetChar = target.Character
    local targetHead = targetChar and targetChar:FindFirstChild("Head")
    if not (head and targetHead) then return false end
    local origin = head.Position
    local direction = (targetHead.Position - origin)
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    raycastParams.FilterDescendantsInstances = {char}
    raycastParams.IgnoreWater = true
    local result = workspace:Raycast(origin, direction, raycastParams)
    if not result then return true end
    if result.Instance and result.Instance:IsDescendantOf(targetChar) then return true end
    return false
end

local function GetClosestTarget()
    local closestTarget, closestDistance = nil, math.huge
    for _, target in ipairs(GetAllTargets()) do
        local pos = GetTargetPosition(target)
        if pos then
            local screenPos, onScreen = Camera:WorldToViewportPoint(pos)
            if onScreen then
                local visible = true
                if aimbotWallCheck then
                    visible = IsVisible(target)
                end
                if IsTargetInFOV(pos) and visible then
                    local dist = (Vector2.new(screenPos.X, screenPos.Y) - FOVCircle.Position).Magnitude
                    if dist < closestDistance then
                        closestDistance = dist
                        closestTarget = target
                    end
                end
            end
        end
    end
    return closestTarget
end

local aimbotSensitivity = 0.2
MainTab:CreateSlider({ Name = "Aimbot Sensitivity", Range = {0.01, 1}, Increment = 0.01, Suffix = "", CurrentValue = 0.2, Flag = "AimbotSensitivity", Callback = function(Value)
    aimbotSensitivity = Value
end })
local aimbotKey = Enum.KeyCode.E
local aimbotKeyHeld = false
local function GetKeyName(input)
    if input.UserInputType == Enum.UserInputType.Keyboard then
        return tostring(input.KeyCode)
    elseif input.UserInputType == Enum.UserInputType.MouseButton1 then
        return "MouseButton1 (LMB)"
    elseif input.UserInputType == Enum.UserInputType.MouseButton2 then
        return "MouseButton2 (RMB)"
    elseif input.UserInputType == Enum.UserInputType.MouseButton3 then
        return "MouseButton3 (MMB)"
    else
        return tostring(input.UserInputType)
    end
end
MainTab:CreateButton({ Name = "Set Aimbot Hold Key (Click then press key/mouse)", Callback = function()
    local conn
    conn = UserInputService.InputBegan:Connect(function(input, processed)
        if not processed then
            if input.UserInputType == Enum.UserInputType.Keyboard then
                aimbotKey = input.KeyCode
            elseif input.UserInputType == Enum.UserInputType.MouseButton1 or
                   input.UserInputType == Enum.UserInputType.MouseButton2 or
                   input.UserInputType == Enum.UserInputType.MouseButton3 then
                aimbotKey = input.UserInputType
            else
                return
            end
            Rayfield:Notify({ Title = "Aimbot Keybind Set", Content = "Now holding: " .. GetKeyName(input), Duration = 2 })
            conn:Disconnect()
        end
    end)
end })
UserInputService.InputBegan:Connect(function(input, processed)
    if not processed then
        if (input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == aimbotKey)
        or (input.UserInputType ~= Enum.UserInputType.Keyboard and input.UserInputType == aimbotKey) then
            aimbotKeyHeld = true
        end
    end
end)
UserInputService.InputEnded:Connect(function(input, processed)
    if (input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == aimbotKey)
    or (input.UserInputType ~= Enum.UserInputType.Keyboard and input.UserInputType == aimbotKey) then
        aimbotKeyHeld = false
    end
end)
RunService.RenderStepped:Connect(function()
    if aimbotEnabled and aimbotKeyHeld then
        local target = GetClosestTarget()
        if target then
            local pos = GetTargetPosition(target)
            if pos then
                local screenPos, onScreen = Camera:WorldToViewportPoint(pos)
                if onScreen then
                    local mouseLocation = UserInputService:GetMouseLocation()
                    local delta = Vector2.new(screenPos.X, screenPos.Y) - mouseLocation
                    mousemoverel(delta.X * aimbotSensitivity, delta.Y * aimbotSensitivity)
                end
            end
        end
    end
end)

-----------------------------------------------------------------
-- ESP Section
-----------------------------------------------------------------
local ESPTab = Window:CreateTab("ESP", "Eye")
ESPTab:CreateSection("ESP Features")

local espEnabled = false
local espTracersEnabled, espBoxesEnabled = false, false
local espNamesEnabled, espDistancesEnabled, espHealthEnabled = false, false, false
local espTracerColor = Color3.fromRGB(0, 255, 0)
local espBoxColor = Color3.fromRGB(255, 0, 0)
local espNameColor = Color3.fromRGB(255, 255, 255)
local espDistanceColor = Color3.fromRGB(255, 255, 0)
local espHealthColor = Color3.fromRGB(0, 255, 0)
local espTeamCheck, espTeamColors = false, false

local espDrawings = {}

local function UpdateAllESPColors()
    for _, d in pairs(espDrawings) do
        if d.tracer then d.tracer.Color = espTracerColor end
        if d.box then d.box.Color = espBoxColor end
        if d.name then d.name.Color = espNameColor end
        if d.distance then d.distance.Color = espDistanceColor end
        if d.health then d.health.Color = espHealthColor end
    end
end

local function ClearESPForPlayer(player)
    local d = espDrawings[player]
    if d then
        if d.tracer then pcall(function() d.tracer:Remove() end) end
        if d.box then pcall(function() d.box:Remove() end) end
        if d.name then pcall(function() d.name:Remove() end) end
        if d.distance then pcall(function() d.distance:Remove() end) end
        if d.health then pcall(function() d.health:Remove() end) end
        espDrawings[player] = nil
    end
end

local function ClearAllESP()
    for player, _ in pairs(espDrawings) do
        ClearESPForPlayer(player)
    end
end

Players.PlayerRemoving:Connect(ClearESPForPlayer)

-- UI Toggles
ESPTab:CreateToggle({ Name = "Enable ESP", CurrentValue = false, Callback = function(val)
    espEnabled = val
    if not val then ClearAllESP() end
    Rayfield:Notify({Title = "ESP", Content = "ESP is now " .. (espEnabled and "ON" or "OFF"), Duration = 2})
end})
ESPTab:CreateToggle({ Name = "Tracers", CurrentValue = false, Callback = function(val)
    espTracersEnabled = val
    Rayfield:Notify({Title = "ESP", Content = "Tracers " .. (espTracersEnabled and "ON" or "OFF"), Duration = 2})
end})
ESPTab:CreateToggle({ Name = "Boxes", CurrentValue = false, Callback = function(val)
    espBoxesEnabled = val
    Rayfield:Notify({Title = "ESP", Content = "Boxes " .. (espBoxesEnabled and "ON" or "OFF"), Duration = 2})
end})
ESPTab:CreateToggle({ Name = "Names", CurrentValue = false, Callback = function(val)
    espNamesEnabled = val
    Rayfield:Notify({Title = "ESP", Content = "Names " .. (espNamesEnabled and "ON" or "OFF"), Duration = 2})
end})
ESPTab:CreateToggle({ Name = "Distances", CurrentValue = false, Callback = function(val)
    espDistancesEnabled = val
    Rayfield:Notify({Title = "ESP", Content = "Distances " .. (espDistancesEnabled and "ON" or "OFF"), Duration = 2})
end})
ESPTab:CreateToggle({ Name = "Health", CurrentValue = false, Callback = function(val)
    espHealthEnabled = val
    Rayfield:Notify({Title = "ESP", Content = "Health " .. (espHealthEnabled and "ON" or "OFF"), Duration = 2})
end})
ESPTab:CreateToggle({ Name = "Team Check (Hide teammates)", CurrentValue = false, Callback = function(val)
    espTeamCheck = val
    Rayfield:Notify({Title = "ESP", Content = "Team Check is now " .. (espTeamCheck and "ON" or "OFF"), Duration = 2})
end})
ESPTab:CreateToggle({ Name = "Team Colors", CurrentValue = false, Callback = function(val)
    espTeamColors = val
    Rayfield:Notify({Title = "ESP", Content = "Team Colors are now " .. (espTeamColors and "ON" or "OFF"), Duration = 2})
    UpdateAllESPColors()
end})
ESPTab:CreateColorPicker({ Name = "Tracer Color", Color = espTracerColor, Callback = function(color)
    espTracerColor = color; UpdateAllESPColors()
end })
ESPTab:CreateColorPicker({ Name = "Box Color", Color = espBoxColor, Callback = function(color)
    espBoxColor = color; UpdateAllESPColors()
end })
ESPTab:CreateColorPicker({ Name = "Name Color", Color = espNameColor, Callback = function(color)
    espNameColor = color; UpdateAllESPColors()
end })
ESPTab:CreateColorPicker({ Name = "Distance Color", Color = espDistanceColor, Callback = function(color)
    espDistanceColor = color; UpdateAllESPColors()
end })
ESPTab:CreateColorPicker({ Name = "Health Color", Color = espHealthColor, Callback = function(color)
    espHealthColor = color; UpdateAllESPColors()
end })

-- ESP Render Loop
RunService.RenderStepped:Connect(function()
    if not espEnabled then
        ClearAllESP()
        return
    end
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("Head") then
            -- Team check
            if espTeamCheck and player.Team == LocalPlayer.Team then
                ClearESPForPlayer(player)
                continue
            end
            local d = espDrawings[player]
            if not d then
                d = {}
                if espTracersEnabled then
                    d.tracer = Drawing.new("Line")
                    d.tracer.Thickness = 2
                end
                if espBoxesEnabled then
                    d.box = Drawing.new("Square")
                    d.box.Thickness = 2
                    d.box.Filled = false
                end
                if espNamesEnabled then
                    d.name = Drawing.new("Text")
                    d.name.Size = 16
                    d.name.Center = true
                    d.name.Outline = true
                end
                if espDistancesEnabled then
                    d.distance = Drawing.new("Text")
                    d.distance.Size = 14
                    d.distance.Center = true
                    d.distance.Outline = true
                end
                if espHealthEnabled then
                    d.health = Drawing.new("Text")
                    d.health.Size = 14
                    d.health.Center = true
                    d.health.Outline = true
                end
                espDrawings[player] = d
            end

            -- get positions
            local char = player.Character
            local head = char and char:FindFirstChild("Head")
            local hrp = char and char:FindFirstChild("HumanoidRootPart")
            local humanoid = char and char:FindFirstChildOfClass("Humanoid")
            if not (head and hrp) then ClearESPForPlayer(player) continue end

            local headScreen, vis1 = Camera:WorldToViewportPoint(head.Position)
            local hrpScreen, vis2 = Camera:WorldToViewportPoint(hrp.Position)
            if not (vis1 and vis2) then ClearESPForPlayer(player) continue end

            -- Team color
            local teamColor = espBoxColor
            if espTeamColors and player.Team and player.Team.TeamColor then
                teamColor = player.Team.TeamColor.Color
            end

            -- TRACER
            if d.tracer then
                d.tracer.Color = espTracerColor
                d.tracer.Visible = espTracersEnabled
                if d.tracer.Visible then
                    d.tracer.From = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y)
                    d.tracer.To = Vector2.new(hrpScreen.X, hrpScreen.Y)
                end
            end
            -- BOX
            if d.box then
                d.box.Color = teamColor
                d.box.Visible = espBoxesEnabled
                if d.box.Visible then
                    -- Simple box between HRP and Head
                    local minX = math.min(headScreen.X, hrpScreen.X)
                    local minY = math.min(headScreen.Y, hrpScreen.Y)
                    local maxX = math.max(headScreen.X, hrpScreen.X)
                    local maxY = math.max(headScreen.Y, hrpScreen.Y)
                    d.box.Position = Vector2.new(minX, minY)
                    d.box.Size = Vector2.new(maxX - minX, maxY - minY)
                end
            end
            -- NAME
            if d.name then
                d.name.Color = espNameColor
                d.name.Visible = espNamesEnabled
                if d.name.Visible then
                    d.name.Text = player.Name
                    d.name.Position = Vector2.new(headScreen.X, headScreen.Y - 20)
                end
            end
            -- DISTANCE
            if d.distance then
                d.distance.Color = espDistanceColor
                d.distance.Visible = espDistancesEnabled
                if d.distance.Visible and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    local dist = (LocalPlayer.Character.HumanoidRootPart.Position - hrp.Position).Magnitude
                    d.distance.Text = string.format("%.1f m", dist)
                    d.distance.Position = Vector2.new(headScreen.X, headScreen.Y - 5)
                end
            end
            -- HEALTH
            if d.health then
                d.health.Color = espHealthColor
                d.health.Visible = espHealthEnabled
                if d.health.Visible and humanoid then
                    d.health.Text = "HP: " .. math.floor(humanoid.Health)
                    d.health.Position = Vector2.new(headScreen.X, headScreen.Y + 10)
                end
            end
        else
            ClearESPForPlayer(player)
        end
    end
end)
